\subsection{Программная реализация Диффи-Хеллмана}

\subsubsection{Структура класса и зависимости}
Реализация протокола инкапсулирована в класс `DiffieHellman`, который, аналогично `RSA`, наследуется от абстрактного базового класса `Protocol`. Это обеспечивает унифицированный интерфейс для всех криптографических протоколов в системе. Для работы с большими числами, необходимыми для криптографической стойкости, используется библиотека `Boost.Multiprecision` с типом `BigInt`. Интеграция с пользовательским интерфейсом Qt обеспечивается за счет использования типа `QString` для текстовых данных.

\input{src/embeds/code/08_dh_header}

\subsubsection{Инициализация и генерация ключей}
В отличие от RSA, где одна сторона генерирует пару ключей, в протоколе DH каждый участник (назовем их Алиса и Боб) выполняет свой собственный процесс генерации. Этот процесс реализован в методе `init()`, который вызывает внутренний метод `generateParametersAndKeys()`.

\begin{enumerate}
    \item \textbf{Согласование публичных параметров.} На первом этапе обе стороны должны согласовать два числа: большое простое число $p$ (модуль) и целое число $g$ (генератор или первообразный корень по модулю $p$). В данной реализации каждый участник генерирует свое простое число $p$ с помощью вспомогательного метода `generatePrime()`, который использует тест Миллера-Рабина для проверки на простоту. Для симуляции предполагается, что участники "договариваются" об использовании одного из этих наборов параметров (на практике параметры $p$ и $g$ часто стандартизированы и общеизвестны). В качестве генератора $g$ для простоты используется константное значение $5$.

    \item \textbf{Генерация секретного ключа.} Каждый участник генерирует свой собственный секретный ключ — случайное целое число. Алиса генерирует число $a$, а Боб — $b$. Эти числа должны находиться в диапазоне $[2, p-2]$ и храниться в строжайшем секрете.
    
    \item \textbf{Вычисление открытого ключа.} Используя публичные параметры и свой секретный ключ, каждый участник вычисляет свой открытый ключ.
    \begin{itemize}
        \item Алиса вычисляет: $A = g^a \pmod{p}$
        \item Боб вычисляет: $B = g^b \pmod{p}$
    \end{itemize}
    Для выполнения модульного возведения в степень используется оптимизированная функция `boost::multiprecision::powm`.
\end{enumerate}

\input{src/embeds/code/09_dh_key_generation}

\subsubsection{Обмен ключами и вычисление общего секрета}
После генерации ключей участники обмениваются своими открытыми ключами ($A$ и $B$) по публичному каналу. Процесс обмена и последующего вычисления общего секрета управляется классом `DiffieHellmanExchanger`.

\begin{enumerate}
    \item \textbf{Обмен.} Алиса отправляет Бобу свой открытый ключ $A$, а Боб отправляет Алисе свой ключ $B$. В программной реализации это симулируется вызовом метода `setOtherPartyPublicKey()`.

    \item \textbf{Вычисление общего секрета.} Получив открытый ключ другой стороны, каждый участник может вычислить общий секретный ключ $s$. Важнейшим свойством протокола является то, что обе стороны получают одинаковый результат, выполняя вычисления независимо друг от друга.
    \begin{itemize}
        \item Алиса вычисляет: $s = B^a \pmod{p} = (g^b)^a \pmod{p}$
        \item Боб вычисляет: $s = A^b \pmod{p} = (g^a)^b \pmod{p}$
    \end{itemize}
    В результате $s = g^{ab} \pmod{p}$ становится их общим секретом. Злоумышленник, перехвативший $p, g, A, B$, не может легко вычислить $s$, так как для этого ему потребуется решить задачу дискретного логарифмирования (найти $a$ из $A$ или $b$ из $B$).
\end{enumerate}

\input{src/embeds/code/10_dh_shared_secret_computation}

\subsubsection{Использование общего секрета для шифрования}
Протокол Диффи-Хеллмана предназначен исключительно для обмена ключами и не является протоколом шифрования. Однако для демонстрации успешного установления общего секрета были реализованы методы `encrypt()` и `decrypt()`, которые используют полученный ключ $s$ для симметричного шифрования.

\begin{enumerate}
    \item \textbf{Преобразование данных.} Входная строка `QString` преобразуется в массив байтов `QByteArray` в кодировке UTF-8, а затем в большое целое число `BigInt`.
    
    \item \textbf{Операция шифрования/расшифрования.} В качестве симметричного шифра используется простая операция побитового исключающего "ИЛИ" (XOR) между числовым представлением сообщения и общим секретным ключом $s$.
    \begin{itemize}
        \item Шифрование: `ciphertext\_int = plaintext\_int XOR s`
        \item Расшифрование: `plaintext\_int = ciphertext\_int XOR s`
    \end{itemize}
    Так как операция XOR является обратимой, один и тот же метод фактически выполняет и шифрование, и расшифрование.

    \item \textbf{Формат передачи.} Для передачи зашифрованные данные преобразуются в шестнадцатеричную строку. При расшифровании выполняется обратное преобразование из шестнадцатеричной строки в `BigInt`.
\end{enumerate}

\subsection{Пример работы протокола Диффи-Хеллмана}
На рисунке ниже продемонстрирован интерфейс виджета, симулирующего работу протокола. После нажатия на кнопку "Выполнить обмен ключами (DH)" в логе отображается процесс установления общего секрета. Затем Алиса и Боб могут обмениваться зашифрованными сообщениями, подтверждая, что они обладают одним и тем же ключом.

\input{src/embeds/images/02_dh_example}