\subsection{Программная реализация схемы Эль-Гамаля}

\subsubsection{Структура класса и зависимости}
Реализация инкапсулирована в класс `ElGamal`, который, как и `RSA`, наследуется от абстрактного базового класса `Protocol`. Это обеспечивает унифицированный интерфейс для работы с различными криптосистемами. Структура класса и его ключевые параметры определены в заголовочном файле `elgamal.hpp`.

\input{src/embeds/code/04_elgamal_header}

\subsubsection{Генерация параметров и ключей}
В отличие от RSA, в схеме Эль-Гамаля процесс инициализации разделен на два логических этапа: генерация общих криптографических параметров и создание ключевой пары на их основе. Эти этапы выполняются в методе `init()`, который вызывает `generateParameters()` и `generateKeys()`.

\begin{enumerate}
    \item \textbf{Генерация простого модуля $p$ и генератора $g$.} Сначала генерируется большое простое число $p$ заданной битовой длины с помощью метода `generatePrime()`, использующего тест Миллера–Рабина (25 итераций) для проверки простоты. Затем выбирается генератор $g$ циклической группы по модулю $p$. Для упрощения реализации в качестве $g$ выбрано значение 2. В криптографически стойких системах выбор генератора является более сложной задачей, но для демонстрационных целей это приемлемо.
    
    \item \textbf{Выбор секретного ключа $d$.} Секретный ключ $d$ выбирается как случайное целое число из диапазона $1 < d < p-1$.
    
    \item \textbf{Вычисление открытого ключа $e$.} Открытый ключ $e$ вычисляется на основе $g$ и $d$ по формуле $e = g^d \pmod p$. Для этого используется функция модульного возведения в степень `boost::multiprecision::powm`.
\end{enumerate}

\input{src/embeds/code/05_elgamal_key_generation}

\subsubsection{Шифрование и расшифрование}
Особенностью схемы Эль-Гамаля является то, что шифртекст состоит из двух частей, а сам процесс шифрования является вероятностным.

\subsubsection*{Шифрование}
Метод `encrypt()` выполняет следующие шаги:
\begin{enumerate}
    \item Входная строка `QString` преобразуется в большое целое число $s$ через промежуточное представление в виде шестнадцатеричной строки, аналогично реализации в RSA.
    \item Проверяется, что полученное число $s$ меньше модуля $p$.
    \item \textbf{Генерация сессионного ключа $k$.} Для каждого акта шифрования генерируется новое случайное число $k$ (эфермерный ключ) в диапазоне $1 < k < p-1$. Использование уникального $k$ для каждого сообщения обеспечивает вероятностный характер шифрования.
    \item \textbf{Вычисление первой компоненты шифртекста $r$.} Первая часть вычисляется как $r = g^k \pmod p$.
    \item \textbf{Вычисление второй компоненты шифртекста $c$.} Вторая часть вычисляется по формуле $c = s \cdot e^k \pmod p$.
    \item Компоненты $r$ и $c$ преобразуются в шестнадцатеричные строки и объединяются через пробел для формирования итогового шифртекста.
\end{enumerate}

\input{src/embeds/code/06_elgamal_encryption}

\subsubsection*{Расшифрование}
Метод `decrypt()` выполняет обратную последовательность действий для восстановления исходного сообщения:
\begin{enumerate}
    \item Входной шифртекст разделяется по пробелу на две шестнадцатеричные строки, представляющие компоненты $r$ и $c$.
    \item Обе строки преобразуются в большие целые числа `BigInt`.
    \item \textbf{Выполняется операция расшифрования.} Исходное сообщение $s$ восстанавливается по формуле $s = c \cdot (r^d)^{-1} \pmod p$. Практически это реализуется в несколько шагов:
    \begin{itemize}
        \item Вычисляется значение $r^d \pmod p$.
        \item Для полученного значения находится мультипликативное обратное по модулю $p$ с помощью вспомогательной функции `inverse()`, реализующей расширенный алгоритм Евклида.
        \item Компонента $c$ умножается на найденное обратное значение по модулю $p$.
    \end{itemize}
    \item Расшифрованное число преобразуется обратно в шестнадцатеричную строку. Как и в RSA, выполняется коррекция: если строка имеет нечетную длину, в начало добавляется ведущий ноль для правильного последующего преобразования.
    \item Скорректированная шестнадцатеричная строка преобразуется в `QByteArray`, а затем в `QString` в кодировке UTF-8.
\end{enumerate}

\input{src/embeds/code/07_elgamal_decryption}

\subsection{Пример работы схемы Эль-Гамаля}
\input{src/embeds/images/01_elgamal_example}