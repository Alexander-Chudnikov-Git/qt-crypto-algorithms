\subsection{Программная реализация RSA}

\subsubsection{Структура класса и зависимости}
Реализация инкапсулирована в класс `RSA`, который наследуется от абстрактного базового класса `Protocol`. Это позволяет в будущем легко интегрировать другие криптографические протоколы в единую систему. В заголовочном файле `rsa.hpp` определена структура класса и его основные компоненты.

\input{src/embeds/code/00_rsa_header}

\subsubsection{Генерация ключей}
Процесс генерации ключевой пары является наиболее важным и сложным этапом. Он реализован в методе `generateKeys()` и соответствует классическому алгоритму.

\begin{enumerate}
    \item \textbf{Генерация простых чисел $p$ и $q$.} Для этого используется вспомогательный метод `generatePrime()`, который генерирует случайное число заданной битовой длины и проверяет его на простоту с помощью вероятностного теста Миллера–Рабина. В реализации используется 25 итераций теста, что обеспечивает чрезвычайно высокую вероятность того, что сгенерированное число действительно является простым. Генерация продолжается до тех пор, пока не будут найдены два различных простых числа.
    
    \item \textbf{Вычисление модуля $m$ и функции Эйлера $\varphi(m)$.} Модуль вычисляется как $m = p \cdot q$, а значение функции Эйлера — как $\varphi(m) = (p-1)(q-1)$.
    
    \item \textbf{Выбор открытой экспоненты $e$.} В качестве открытой экспоненты выбрано стандартное значение $e = 65537$. Это число является простым и имеет всего два единичных бита в двоичном представлении ($2^{16}+1$), что позволяет значительно ускорить операцию возведения в степень при шифровании. Производится проверка, что $\text{НОД}(e, \varphi(m))=1$.
    
    \item \textbf{Вычисление секретной экспоненты $d$.} Секретная экспонента $d$ вычисляется как мультипликативное обратное к $e$ по модулю $\varphi(m)$, то есть $d \equiv e^{-1} \pmod{\varphi(m)}$. Для этого используется расширенный алгоритм Евклида, реализованный в отдельной функции `inverse()`.
\end{enumerate}

\input{src/embeds/code/01_rsa_key_generation}

\subsubsection{Шифрование и расшифрование}
Процессы шифрования и расшифрования требуют преобразования текстовых данных в числовое представление и обратно.

\subsubsection*{Шифрование}
Метод `encrypt()` выполняет следующие шаги:
\begin{enumerate}
    \item Входная строка `QString` преобразуется в массив байтов `QByteArray` в кодировке UTF-8.
    \item Байтовый массив представляется в виде строки шестнадцатеричных символов. Это необходимо для однозначного преобразования двоичных данных в число.
    \item Шестнадцатеричная строка преобразуется в большое целое число `BigInt`.
    \item Производится проверка, что полученное число меньше модуля $m$.
    \item Выполняется основная операция шифрования: $c = s^e \pmod m$ с помощью функции `boost::multiprecision::powm`, оптимизированной для модульного возведения в степень.
    \item Полученный шифртекст $c$ преобразуется обратно в шестнадцатеричную строку для передачи.
\end{enumerate}

\input{src/embeds/code/02_rsa_encryption}

\subsubsection*{Расшифрование}
Метод `decrypt()` выполняет обратную последовательность действий:
\begin{enumerate}
    \item Входной шифртекст в виде шестнадцатеричной строки преобразуется в большое целое число `BigInt`.
    \item Выполняется операция расшифрования: $s = c^d \pmod m$ с помощью функции `powm`.
    \item Расшифрованное число преобразуется обратно в шестнадцатеричную строку.
    \item На этом этапе выполняется важная коррекция: если полученная строка имеет нечетную длину, в начало добавляется ведущий ноль. Это необходимо, так как при преобразовании числа в строку `0x0F` может превратиться в `"f"` вместо `"0f"`, что приведет к ошибке на следующем шаге.
    \item Скорректированная шестнадцатеричная строка преобразуется в `QByteArray`, а затем в `QString` в кодировке UTF-8, восстанавливая исходное сообщение.
\end{enumerate}

\input{src/embeds/code/03_rsa_decryption}

\subsection{Пример работы RSA}
\input{src/embeds/images/00_rsa_example}